generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  RESPONDER
}

enum UserStatus {
  INVITED
  ACTIVE
  DISABLED
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

enum AuditEntityType {
  USER
  TEAM
  TEAM_MEMBER
  SERVICE
  ESCALATION_POLICY
}

enum ServiceStatus {
  OPERATIONAL
  DEGRADED
  PARTIAL_OUTAGE
  MAJOR_OUTAGE
  MAINTENANCE
}

enum IncidentStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
  SNOOZED
  SUPPRESSED
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  SLACK
  WEBHOOK
  WHATSAPP
}

enum InAppNotificationType {
  INCIDENT
  SCHEDULE
  TEAM
  SERVICE
}

enum DigestLevel {
  HIGH
  ALL
  NONE
}

enum IncidentUrgency {
  LOW
  HIGH
}

enum EscalationTargetType {
  USER
  TEAM
  SCHEDULE
}

model User {
  id                           String      @id @default(cuid())
  name                         String
  email                        String      @unique
  role                         Role        @default(USER)
  status                       UserStatus  @default(INVITED)
  passwordHash                 String?
  timeZone                     String      @default("UTC")
  dailySummary                 Boolean     @default(true)
  incidentDigest               DigestLevel @default(HIGH)
  // Notification preferences (user-level, like PagerDuty)
  emailNotificationsEnabled    Boolean     @default(false)
  smsNotificationsEnabled      Boolean     @default(false)
  pushNotificationsEnabled     Boolean     @default(false)
  whatsappNotificationsEnabled Boolean     @default(false)
  phoneNumber                  String? // For SMS notifications
  invitedAt                    DateTime?
  deactivatedAt                DateTime?
  createdAt                    DateTime    @default(now())
  updatedAt                    DateTime    @updatedAt

  assignedIncidents    Incident[]
  teamMemberships      TeamMember[]
  onCallShifts         OnCallShift[]
  escalationRules      EscalationRule[]
  incidentNotes        IncidentNote[]
  postmortems          Postmortem[]
  notifications        Notification[]
  inAppNotifications   InAppNotification[]
  devices              UserDevice[]
  incidentWatchers     IncidentWatcher[]
  auditLogs            AuditLog[]
  overrides            OnCallOverride[]       @relation("OverrideUser")
  overrideReplacements OnCallOverride[]       @relation("OverrideReplacesUser")
  searchPresets        SearchPreset[]
  searchPresetUsage    SearchPresetUsage[]
  layerAssignments     OnCallLayerUser[]
  accounts             Account[]
  sessions             Session[]
  apiKeys              ApiKey[]
  incidentTemplates    IncidentTemplate[]
  updatedProviders     NotificationProvider[]
  teamsLed             Team[]                 @relation("TeamLead")
  slackIntegrations    SlackIntegration[]
  slackOAuthConfigs    SlackOAuthConfig[]     @relation("SlackOAuthConfigUpdater")
  oidcConfigs          OidcConfig[]

  @@index([email]) // CRITICAL: Performance index for email lookups (fixes 2-4s queries)
  @@index([role, status]) // For filtering users by role and status
  @@index([status]) // For active user queries
}

model Team {
  id          String   @id @default(cuid())
    name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members           TeamMember[]
  services          Service[]
  escalationRules   EscalationRule[]
  incidentTemplates IncidentTemplate[]
  incidents         Incident[] // Team-assigned incidents
  teamLeadId        String?
  teamLead          User?              @relation("TeamLead", fields: [teamLeadId], references: [id])
}

model TeamMember {
  id     String   @id @default(cuid())
  userId String
  teamId String
  role   TeamRole @default(MEMBER)
  receiveTeamNotifications Boolean @default(true) // Team-specific notification preference

  user User @relation(fields: [userId], references: [id])
  team Team @relation(fields: [teamId], references: [id])

  @@unique([userId, teamId])
}

model Service {
  id                          String                @id @default(cuid())
    name                        String                @unique
  description                 String?
  region                      String? // Service hosting region (e.g., US-East, EU-West)
  slaTier                     String? // e.g., Gold, Silver, Bronze
  status                      ServiceStatus         @default(OPERATIONAL)
  targetAckMinutes            Int                   @default(15)
  targetResolveMinutes        Int                   @default(120)
  teamId                      String?
  escalationPolicyId          String?
  slackWebhookUrl             String? // Per-service Slack Webhook URL (only notification config at service level)
  slackChannel                String? // Slack channel name (e.g., #incidents)
  slackWorkspaceId            String? // Slack workspace ID for future multi-workspace support
  slackIntegrationId          String?               @unique // Reference to SlackIntegration (OAuth-based)
  webhookUrl                  String? // Per-service generic webhook URL
  serviceNotificationChannels NotificationChannel[] @default([]) // Service-level notification channels (isolated from escalation)
  createdAt                   DateTime              @default(now())
  updatedAt                   DateTime              @updatedAt

  team      Team?             @relation(fields: [teamId], references: [id])
  incidents Incident[]
  policy    EscalationPolicy? @relation(fields: [escalationPolicyId], references: [id])

  integrations        Integration[]
  alerts              Alert[]
  incidentTemplates   IncidentTemplate[]
  statusPageServices  StatusPageService[]
  webhookIntegrations WebhookIntegration[]
  slackIntegration    SlackIntegration?    @relation("ServiceSlackIntegration", fields: [slackIntegrationId], references: [id], onDelete: Cascade)
  slaDefinitions      SLADefinition[]
}

// Enhanced Escalation Policy
model EscalationPolicy {
  id          String  @id @default(cuid())
    name        String  @unique
  description String?

  // Replaced simple JSON with relational steps
  steps EscalationRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services Service[]
}

model EscalationRule {
  id       String           @id @default(cuid())
  policyId String
  policy   EscalationPolicy @relation(fields: [policyId], references: [id])

  delayMinutes Int @default(0) // Time to wait before escalating to next step
  stepOrder    Int // 0, 1, 2...

  // Target type and ID - one of these will be set based on targetType
  targetType       EscalationTargetType @default(USER)
  targetUserId     String?
  targetTeamId     String?
  targetScheduleId String?

  // Notification channels for this escalation step (overrides user preferences if set)
  notificationChannels NotificationChannel[] // Per-step channel configuration

  // Team-specific options
  notifyOnlyTeamLead Boolean @default(false) // If true, only notify team lead instead of all team members

  targetUser     User?           @relation(fields: [targetUserId], references: [id])
  targetTeam     Team?           @relation(fields: [targetTeamId], references: [id])
  targetSchedule OnCallSchedule? @relation(fields: [targetScheduleId], references: [id])
}

model Integration {
  id        String   @id @default(cuid())
  name      String
  type      String   @default("EVENTS_API_V2") // EVENTS_API_V2, EMAIL, etc.
  key       String   @unique // The routing key used in API calls
  serviceId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id])
}

model WebhookIntegration {
  id        String   @id @default(cuid())
  serviceId String
    name      String   @unique // "Google Chat", "Microsoft Teams", etc.
  type      String // "GOOGLE_CHAT", "TEAMS", "DISCORD", "GENERIC"
  url       String
  secret    String? // For HMAC signature
  channel   String? // Channel/room name
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([serviceId])
}

// Slack OAuth Configuration (Global - stored in database)
model SlackOAuthConfig {
  id           String   @id @default(cuid())
  clientId     String // Slack App Client ID
  clientSecret String // Encrypted Slack App Client Secret
  redirectUri  String? // Custom redirect URI (optional)
  enabled      Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  updatedBy    String // User ID who last updated the config
  updater      User     @relation("SlackOAuthConfigUpdater", fields: [updatedBy], references: [id])

  @@unique([id]) // Only one config record
}


// OIDC Single Sign-On Configuration (Global - stored in database)
model OidcConfig {
  id             String   @id @default("default")
  issuer         String
  clientId       String
  clientSecret   String
  enabled        Boolean  @default(true)
  autoProvision  Boolean  @default(true)
  allowedDomains String[] @default([])
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  updatedBy      String
  updater        User     @relation(fields: [updatedBy], references: [id])

  @@unique([id])
}

// Slack OAuth Integration
model SlackIntegration {
  id            String   @id @default(cuid())
  workspaceId   String // Slack workspace/team ID
  workspaceName String? // Slack workspace name
  botToken      String // Encrypted bot token (xoxb-...)
  signingSecret String? // Encrypted signing secret
  installedBy   String // User ID who installed the integration
  scopes        String[] // OAuth scopes granted
  enabled       Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  service   Service? @relation("ServiceSlackIntegration")
  installer User     @relation(fields: [installedBy], references: [id])

  @@unique([workspaceId]) // One integration per workspace (can be global or service-specific)
  @@index([workspaceId])
}

model Alert {
  id         String   @id @default(cuid())
  dedupKey   String? // The deduplication key from the event source
  status     String   @default("TRIGGERED") // TRIGGERED, RESOLVED
  payload    Json // The full event payload
  serviceId  String
  incidentId String?
  createdAt  DateTime @default(now())

  service  Service   @relation(fields: [serviceId], references: [id])
  incident Incident? @relation(fields: [incidentId], references: [id])

  @@index([serviceId, status]) // For querying alerts by service and status
  @@index([incidentId]) // For querying alerts by incident
  @@index([dedupKey, status]) // For deduplication queries
  @@index([createdAt]) // For time-based queries
}

model Incident {
  id                     String          @id @default(cuid())
  title                  String
  description            String?
  status                 IncidentStatus  @default(OPEN)
  urgency                IncidentUrgency @default(HIGH)
  priority               String? // P1, P2.. P5
  dedupKey               String? // Key for deduplication
  serviceId              String
  assigneeId             String?
  teamId                 String? // Team assignment (mutually exclusive with assigneeId)
  currentEscalationStep  Int? // Current step index (0-based)
  nextEscalationAt       DateTime? // When to execute next escalation step
  escalationStatus       String? // ESCALATING, COMPLETED, PAUSED
  escalationProcessingAt DateTime? // When escalation processing was claimed
  acknowledgedAt         DateTime? // When incident was acknowledged (for SLA tracking)
  resolvedAt             DateTime? // When incident was resolved (for SLA tracking)
  snoozedUntil           DateTime? // When to auto-unsnooze (for time-based snoozing)
  snoozeReason           String? // Reason for snoozing
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt

  service                 Service                  @relation(fields: [serviceId], references: [id])
  assignee                User?                    @relation(fields: [assigneeId], references: [id])
  team                    Team?                    @relation(fields: [teamId], references: [id])
  events                  IncidentEvent[]
  notes                   IncidentNote[]
  postmortem              Postmortem?
  statusPageAnnouncements StatusPageAnnouncement[]
  customFieldValues       CustomFieldValue[]
  alerts                  Alert[] // Relation to raw alerts
  notifications           Notification[]
  watchers                IncidentWatcher[]
  tags                    IncidentTag[]

  @@index([dedupKey]) // Index for fast deduplication lookups
  @@index([serviceId, dedupKey, status]) // For service-scoped deduplication checks
  @@index([nextEscalationAt, escalationStatus]) // Index for escalation processing queries
  @@index([escalationProcessingAt]) // For escalation processing locks
  @@index([snoozedUntil]) // Index for auto-unsnooze processing
  @@index([status, createdAt]) // For filtering incidents by status and date
  @@index([serviceId, status]) // For querying incidents by service and status
  @@index([assigneeId, status]) // For querying incidents by assignee and status
  @@index([teamId, status]) // For querying incidents by team and status
  @@index([createdAt]) // For time-based queries and sorting
  @@index([urgency, status]) // For filtering by urgency and status
  @@index([status, urgency, createdAt]) // Composite for count queries with urgency and date filter
  @@index([status, assigneeId]) // For unassigned count queries (assigneeId: null)

  // Performance Optimization: Indexes for Analytics & Dashboard Counts
  @@index([status]) // For simple count queries (e.g. "Open Incidents")
  @@index([acknowledgedAt]) // For MTTA calculations
  @@index([resolvedAt]) // For MTTR calculations
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String? // Optional color for tag
  createdAt DateTime @default(now())

  incidents IncidentTag[]
}

model IncidentTag {
  id         String   @id @default(cuid())
  incidentId String
  tagId      String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([incidentId, tagId])
  @@index([incidentId])
  @@index([tagId])
}

model IncidentTemplate {
  id               String          @id @default(cuid())
    name             String          @unique
  description      String?
  title            String // Default title for incidents created from this template
  descriptionText  String? // Default description text
  defaultUrgency   IncidentUrgency @default(HIGH)
  defaultPriority  String? // P1-P5
  defaultServiceId String? // Default service to use
  createdById      String // User who created the template
  isPublic         Boolean         @default(false) // Whether template is available to all users
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  createdBy      User     @relation(fields: [createdById], references: [id])
  defaultService Service? @relation(fields: [defaultServiceId], references: [id])
  Team           Team?    @relation(fields: [teamId], references: [id])
  teamId         String?

  @@index([createdById])
}

model IncidentWatcher {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  role       String   @default("FOLLOWER") // FOLLOWER, STAKEHOLDER, EXEC
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@unique([incidentId, userId])
}

model IncidentEvent {
  id         String   @id @default(cuid())
  incidentId String
  message    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId, createdAt]) // For querying events by incident chronologically
}

model IncidentNote {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  content    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId, createdAt]) // For querying notes by incident chronologically
}

model Postmortem {
  id          String    @id @default(cuid())
  incidentId  String    @unique // One postmortem per incident
  title       String
  summary     String? // Executive summary
  timeline    Json? // Timeline of events (JSON array)
  impact      Json? // Impact assessment (JSON object)
  rootCause   String? // Root cause analysis
  resolution  String? // How it was resolved
  actionItems Json? // Action items (JSON array)
  lessons     String? // Lessons learned
  status      String    @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  isPublic    Boolean   @default(true) // Public visibility on status page
  publishedAt DateTime?
  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  incident  Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  createdBy User     @relation(fields: [createdById], references: [id])

  @@index([incidentId])
  @@index([status, createdAt])
  @@index([createdById])
}

model OnCallSchedule {
  id              String           @id @default(cuid())
    name            String           @unique
  timeZone        String           @default("UTC")
  layers          OnCallLayer[]
  overrides       OnCallOverride[]
  shifts          OnCallShift[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  escalationRules EscalationRule[]
}

model OnCallLayer {
  id                  String    @id @default(cuid())
  scheduleId          String
  name                String
  start               DateTime
  end                 DateTime?
  rotationLengthHours Int       @default(24)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  schedule OnCallSchedule    @relation(fields: [scheduleId], references: [id])
  users    OnCallLayerUser[]
}

model OnCallLayerUser {
  id       String @id @default(cuid())
  layerId  String
  userId   String
  position Int    @default(0)

  layer OnCallLayer @relation(fields: [layerId], references: [id])
  user  User        @relation(fields: [userId], references: [id])

  @@unique([layerId, userId])
}

model OnCallOverride {
  id             String   @id @default(cuid())
  scheduleId     String
  userId         String
  replacesUserId String?
  start          DateTime
  end            DateTime
  createdAt      DateTime @default(now())

  schedule     OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user         User           @relation("OverrideUser", fields: [userId], references: [id])
  replacesUser User?          @relation("OverrideReplacesUser", fields: [replacesUserId], references: [id])
}

model OnCallShift {
  id         String   @id @default(cuid())
  scheduleId String
  userId     String
  start      DateTime
  end        DateTime

  schedule OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user     User           @relation(fields: [userId], references: [id])

  @@index([start, end]) // For date range queries (active shifts)
  @@index([userId, start, end]) // For user-specific shift queries
}

// Notification model for contact attempts
model Notification {
  id          String              @id @default(cuid())
  incidentId  String
  userId      String
  channel     NotificationChannel
  status      NotificationStatus  @default(PENDING)
  message     String?
  sentAt      DateTime?
  deliveredAt DateTime?
  failedAt    DateTime?
  errorMsg    String?
  attempts    Int                 @default(0) // Retry attempt count
  createdAt   DateTime            @default(now())

  incident Incident @relation(fields: [incidentId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId]) // For querying notifications by incident
  @@index([userId]) // For querying notifications by user
  @@index([status, createdAt]) // For querying pending/failed notifications
  @@index([channel, status]) // For querying by channel and status
}

model InAppNotification {
  id         String                @id @default(cuid())
  userId     String
  type       InAppNotificationType
  title      String
  message    String
  entityType String?
  entityId   String?
  readAt     DateTime?
  createdAt  DateTime              @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt]) // For chronological queries
  @@index([userId, readAt]) // For unread count queries
  @@index([userId, readAt, createdAt]) // Optomized for "Unread" queries (readAt: null)
}

// User device tokens for push notifications
model UserDevice {
  id        String   @id @default(cuid())
  userId    String
  deviceId  String // Unique device identifier
  token     String // FCM/APNS token
  platform  String // 'ios', 'android', 'web'
  userAgent String? // Browser/device info
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@index([userId])
  @@index([token])
}

model AuditLog {
  id         String          @id @default(cuid())
  action     String
  entityType AuditEntityType
  entityId   String?
  actorId    String?
  details    Json?
  createdAt  DateTime        @default(now())

  actor User? @relation(fields: [actorId], references: [id])

  @@index([entityType, entityId]) // For querying audit logs by entity
  @@index([actorId, createdAt]) // For querying audit logs by actor
  @@index([createdAt]) // For time-based queries
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId]) // For session lookups by user
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model ApiKey {
  id         String    @id @default(cuid())
  name       String
  prefix     String
  tokenHash  String
  scopes     String[]
  userId     String
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  revokedAt  DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// System-level notification provider configuration
model NotificationProvider {
  id        String   @id @default(cuid())
  provider  String   @unique // 'twilio', 'resend', 'sendgrid', 'smtp', 'firebase', 'onesignal'
  enabled   Boolean  @default(false)
  // Encrypted configuration (JSON stored as text, should be encrypted in production)
  config    Json // Provider-specific configuration
  updatedBy String? // User ID who last updated
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@index([provider])
}

// Background Job Queue (PostgreSQL-based, no Redis needed)
enum JobType {
  ESCALATION
  NOTIFICATION
  AUTO_UNSNOOZE
  SCHEDULED_TASK
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model BackgroundJob {
  id          String    @id @default(cuid())
  type        JobType
  status      JobStatus @default(PENDING)
  scheduledAt DateTime // When to execute the job
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  error       String? // Error message if failed
  payload     Json // Job-specific data (incidentId, userId, etc.)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([type, status, scheduledAt]) // For efficient job polling
  @@index([status, scheduledAt]) // For finding pending jobs
  @@index([scheduledAt]) // For time-based queries
}

// Status Page Configuration
model StatusPage {
  id            String  @id @default(cuid())
    name          String  @default("Status Page") @unique
  organizationName String? // Dedicated organization name for email branding
  subdomain     String? @unique // Custom subdomain (e.g., status.yourcompany.com)
  customDomain  String? @unique // Custom domain (e.g., status.yourcompany.com)
  enabled       Boolean @default(false)
  showServices  Boolean @default(true)
  showIncidents Boolean @default(true)
  showMetrics   Boolean @default(true)
  showSubscribe Boolean @default(true)
  branding      Json? // Logo, colors, favicon
  footerText    String?
  contactEmail  String?
  contactUrl    String?

  // Privacy settings
  privacyMode              String? @default("PUBLIC") // PUBLIC, RESTRICTED, PRIVATE
  showIncidentDetails      Boolean @default(true)
  showIncidentTitles       Boolean @default(true)
  showIncidentDescriptions Boolean @default(true)
  showAffectedServices     Boolean @default(true)
  showIncidentTimestamps   Boolean @default(true)
  showServiceMetrics       Boolean @default(true)
  showServiceDescriptions  Boolean @default(true)
  showServiceRegions       Boolean @default(true)
  showServicesByRegion     Boolean @default(false)
  showServiceOwners        Boolean @default(false)
  showServiceSlaTier       Boolean @default(false)
  showTeamInformation      Boolean @default(false)
  showCustomFields         Boolean @default(false)
  showIncidentAssignees    Boolean @default(false)
  showIncidentUrgency      Boolean @default(true)
  showUptimeHistory        Boolean @default(true)
  showRecentIncidents      Boolean @default(true)
  showChangelog            Boolean @default(true)
  showRegionHeatmap        Boolean @default(true)
  showPostIncidentReview   Boolean @default(true)
  maxIncidentsToShow       Int     @default(50)
  incidentHistoryDays      Int     @default(90)
  allowedCustomFields      Json? // Array of custom field IDs to show
  dataRetentionDays        Int? // Auto-hide incidents older than X days
  requireAuth              Boolean @default(false) // Require authentication
  authProvider             String? // SSO provider if requireAuth=true
  emailProvider            String? // Email provider for subscription notifications (resend, sendgrid, smtp, or null for auto)
  enableUptimeExports      Boolean @default(false)

  // Status API access controls
  statusApiRequireToken       Boolean @default(false)
  statusApiRateLimitEnabled   Boolean @default(false)
  statusApiRateLimitMax       Int     @default(120)
  statusApiRateLimitWindowSec Int     @default(60)

  // Uptime threshold configuration
  uptimeExcellentThreshold Float @default(99.9) // Threshold for excellent uptime (green)
  uptimeGoodThreshold      Float @default(99.0) // Threshold for good uptime (yellow)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services      StatusPageService[]
  announcements StatusPageAnnouncement[]
  apiTokens     StatusPageApiToken[]
  subscriptions StatusPageSubscription[]
  webhooks      StatusPageWebhook[]

  @@index([enabled])
}

// Services shown on status page
model StatusPageService {
  id           String   @id @default(cuid())
  statusPageId String
  serviceId    String
  displayName  String? // Override service name for status page
  showOnPage   Boolean  @default(true)
  order        Int      @default(0)
  createdAt    DateTime @default(now())

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  service    Service    @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([statusPageId, serviceId])
  @@index([statusPageId, order])
}

// Announcements/Communications on status page
model StatusPageAnnouncement {
  id           String    @id @default(cuid())
  statusPageId String
  title        String
  message      String
  type         String    @default("INFO") // INFO, WARNING, MAINTENANCE, INCIDENT
  incidentId   String? // Link to incident if applicable
  affectedServiceIds Json? // Array of affected service IDs (for maintenance/impact mapping)
  startDate    DateTime
  endDate      DateTime?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  incident   Incident?  @relation(fields: [incidentId], references: [id], onDelete: SetNull)

  @@index([statusPageId, isActive, startDate])
  @@index([incidentId])
}

model StatusPageApiToken {
  id           String   @id @default(cuid())
  statusPageId String
  name         String
  prefix       String
  tokenHash    String
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime?
  revokedAt    DateTime?

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@unique([tokenHash])
  @@index([statusPageId, revokedAt])
}

// Status Page Subscriptions (Email notifications)
model StatusPageSubscription {
  id                String    @id @default(cuid())
  statusPageId      String
  email             String
  phone             String? // For SMS (future)
  token             String    @unique // Unsubscribe token
  subscribedAt      DateTime  @default(now())
  unsubscribedAt    DateTime?
  verified          Boolean   @default(false)
  verificationToken String?
  preferences       Json? // Notification preferences (all incidents, major only, etc.)

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@unique([statusPageId, email])
  @@index([statusPageId, verified])
  @@index([token])
}

// Status Page Webhooks (External integrations)
model StatusPageWebhook {
  id              String    @id @default(cuid())
  statusPageId    String
  url             String
  secret          String // Webhook secret for verification
  events          Json // Array of events to send (incident.created, incident.updated, etc.)
  enabled         Boolean   @default(true)
  lastTriggeredAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@index([statusPageId, enabled])
}

// Custom Fields System
model CustomField {
  id           String          @id @default(cuid())
  name         String
  key          String          @unique // Unique identifier (e.g., "customer_id")
  type         CustomFieldType
  required     Boolean         @default(false)
  defaultValue String?
  options      Json? // For SELECT type: array of options
  order        Int             @default(0)
  showInList   Boolean         @default(false) // Show in incident table
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  values CustomFieldValue[]

  @@index([key])
  @@index([order])
}

enum CustomFieldType {
  TEXT
  NUMBER
  DATE
  SELECT
  BOOLEAN
  URL
  EMAIL
}

model CustomFieldValue {
  id            String   @id @default(cuid())
  incidentId    String
  customFieldId String
  value         String? // Store as string, parse based on field type
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  incident    Incident    @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  customField CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)

  @@unique([incidentId, customFieldId])
  @@index([incidentId])
  @@index([customFieldId])
  @@index([value]) // For filtering
}

// Search Presets / Saved Searches
model SearchPreset {
  id          String  @id @default(cuid())
  name        String
  description String?
  createdById String
  isShared    Boolean @default(false) // Shared with team/organization
  isDefault   Boolean @default(false) // Default preset for new users
  isPublic    Boolean @default(false) // Public preset visible to all users

  // Filter criteria (stored as JSON for flexibility)
  filterCriteria Json // { filter, search, priority, urgency, sort, serviceIds?, assigneeIds?, dateRange?, etc. }

  // Metadata
  icon  String? // Optional icon identifier
  color String? // Optional color for visual distinction
  order Int     @default(0) // Display order

  // Analytics
  usageCount Int       @default(0) // How many times this preset has been used
  lastUsedAt DateTime? // Last time this preset was used

  // Sharing
  sharedWithTeams String[] // Array of team IDs that can access this preset

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdBy User @relation(fields: [createdById], references: [id], onDelete: Cascade)

  // Usage tracking
  usageHistory SearchPresetUsage[]

  @@index([createdById])
  @@index([isShared, isPublic])
  @@index([order])
  @@index([lastUsedAt])
}

// Track preset usage for analytics
model SearchPresetUsage {
  id       String   @id @default(cuid())
  presetId String
  userId   String
  usedAt   DateTime @default(now())


  preset SearchPreset @relation(fields: [presetId], references: [id], onDelete: Cascade)
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([presetId])
  @@index([userId])
  @@index([usedAt])
}

// System-wide settings (singleton pattern)
model SystemSettings {
  id        String   @id @default("default")
  appUrl    String?  // Application base URL for links in emails, webhooks, etc.
  encryptionKey String? // Hex-encoded 32-byte key for encrypting secrets
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------------------------------
// Enterprise Observability Engine Schema
// -----------------------------------------------------------------------------

// ‚öôÔ∏è Governance Layer
// Stores system-wide policies (e.g., retention_policy, sampling_rates)
model SystemConfig {
  key       String   @id // e.g., 'retention_policy'
  value     Json     // Flexible JSON config
  updatedAt DateTime @updatedAt
  updatedBy String?
}

// ü•á Gold Tier: SLA & Business Compliance
// High-Value, Infinite Retention, Audit-Ready
model SLADefinition {
  id          String    @id @default(cuid())
  serviceId   String
  name        String    @default("Standard SLA")
  version     Int       @default(1) // version++ on change
  target      Float     @default(99.9) // e.g., 99.9%
  window      String    @default("30d") // "30d", "quarterly"
  metricType  String    @default("UPTIME") // "UPTIME", "LATENCY_P99"
  activeFrom  DateTime  @default(now())
  activeTo    DateTime? // Null means currently active
  
  service     Service   @relation(fields: [serviceId], references: [id])
  snapshots   SLASnapshot[]

  @@index([serviceId])
}

model SLASnapshot {
  id              String        @id @default(cuid())
  date            DateTime      // The day this snapshot represents (00:00 UTC)
  slaDefinitionId String
  
  // The Frozen Truth (Calculated Nightly)
  totalEvents      Int          @default(0)
  errorEvents      Int          @default(0)
  uptimePercentage Float        @default(100.0)
  breachCount      Int          @default(0)
  errorBudgetBurn  Float        @default(0.0) // Percentage of budget consumed
  
  metadata         Json?        // Context: "Major Outage ID: 123"

  definition      SLADefinition @relation(fields: [slaDefinitionId], references: [id])

  @@unique([date, slaDefinitionId]) // One snapshot per SLA per day
  @@index([date])
}

// ü•à Silver Tier: Performance Trends
// Aggregated Metrics, Configurable Retention (e.g., 90 days)
model MetricRollup {
  id        String   @id @default(cuid())
  bucket    DateTime // Truncated timestamp (Minute or Hour)
  serviceId String?  // Optional: Global metrics might not have a service
  name      String   // e.g., 'http.request.duration', 'db.pool.usage'
  
  tags      Json     // { "method": "GET", "status": "200" }
  
  // Pre-computed Stats
  count     Int
  sum       Float
  min       Float
  max       Float
  p50       Float?
  p90       Float?
  p95       Float?
  p99       Float?

  @@index([name, bucket]) // Fast graph queries
  @@index([bucket])       // Fast cleanup (Smart Janitor)
}

// ü•â Bronze Tier: Incident Debugging
// Raw Events, Short Retention (e.g., 7 days)
model LogEntry {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())
  serviceId String?
  level     String   // ERROR, WARN, INFO, DEBUG
  
  message   String
  context   Json?    // Stack trace, query params, etc.
  traceId   String?  // Propagated Trace ID
  userId    String?  // Anonymized user ID if applicable

  @@index([serviceId, timestamp])
  @@index([timestamp]) // Fast cleanup
  @@index([traceId])
}
