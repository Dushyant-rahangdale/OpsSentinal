generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  RESPONDER
}

enum UserStatus {
  INVITED
  ACTIVE
  DISABLED
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

enum AuditEntityType {
  USER
  TEAM
  TEAM_MEMBER
  SERVICE
  ESCALATION_POLICY
}

enum UserTokenType {
  INVITE
  PASSWORD_RESET
  ADMIN_RESET_LINK
}

enum ServiceStatus {
  OPERATIONAL
  DEGRADED
  PARTIAL_OUTAGE
  MAJOR_OUTAGE
  MAINTENANCE
}

enum IncidentStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
  SNOOZED
  SUPPRESSED
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  SLACK
  WEBHOOK
  WHATSAPP
}

enum InAppNotificationType {
  INCIDENT
  SCHEDULE
  TEAM
  SERVICE
}

enum DigestLevel {
  HIGH
  ALL
  NONE
}

enum IncidentUrgency {
  LOW
  MEDIUM
  HIGH
}

enum IncidentVisibility {
  PUBLIC
  PRIVATE
}

enum EscalationTargetType {
  USER
  TEAM
  SCHEDULE
}

model User {
  id                           String      @id @default(cuid())
  name                         String
  email                        String      @unique
  emailVerified               DateTime?
  // Session revocation marker: increment to force-logout all JWT sessions
  tokenVersion                 Int         @default(0)
  role                         Role        @default(USER)
  status                       UserStatus  @default(INVITED)
  passwordHash                 String?
  timeZone                     String      @default("UTC")
  dailySummary                 Boolean     @default(true)
  incidentDigest               DigestLevel @default(HIGH)
  // Notification preferences (user-level, like PagerDuty)
  emailNotificationsEnabled    Boolean     @default(false)
  smsNotificationsEnabled      Boolean     @default(false)
  pushNotificationsEnabled     Boolean     @default(false)
  whatsappNotificationsEnabled Boolean     @default(false)
  phoneNumber                  String? // For SMS notifications
  // JIT Profile Sync - synced from OIDC provider
  department                   String?
  jobTitle                     String?
  avatarUrl                    String?
  gender                       String?
  lastOidcSync                 DateTime?
  invitedAt                    DateTime?
  deactivatedAt                DateTime?
  createdAt                    DateTime    @default(now())
  updatedAt                    DateTime    @updatedAt

  assignedIncidents    Incident[]
  teamMemberships      TeamMember[]
  onCallShifts         OnCallShift[]
  escalationRules      EscalationRule[]
  incidentNotes        IncidentNote[]
  postmortems          Postmortem[]
  notifications        Notification[]
  inAppNotifications   InAppNotification[]
  devices              UserDevice[]
  incidentWatchers     IncidentWatcher[]
  auditLogs            AuditLog[]
  overrides            OnCallOverride[]       @relation("OverrideUser")
  overrideReplacements OnCallOverride[]       @relation("OverrideReplacesUser")
  layerAssignments     OnCallLayerUser[]

  apiKeys              ApiKey[]
  incidentTemplates    IncidentTemplate[]
  updatedProviders     NotificationProvider[]
  teamsLed             Team[]                 @relation("TeamLead")
  slackIntegrations    SlackIntegration[]
  slackOAuthConfigs    SlackOAuthConfig[]     @relation("SlackOAuthConfigUpdater")
  oidcConfigs          OidcConfig[]
  oidcIdentities       OidcIdentity[]

  @@index([email]) // CRITICAL: Performance index for email lookups (fixes 2-4s queries)
  @@index([role, status]) // For filtering users by role and status
  @@index([status]) // For active user queries
}

// Stable link between an IdP identity (issuer+sub) and an internal user.
// Avoids unsafe "email-only" linking for OIDC sign-in.
model OidcIdentity {
  id      String @id @default(cuid())
  issuer  String
  subject String
  email   String?
  userId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([issuer, subject])
  @@index([userId])
  @@index([issuer])
}

model Team {
  id          String   @id @default(cuid())
    name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members           TeamMember[]
  services          Service[]
  escalationRules   EscalationRule[]
  incidentTemplates IncidentTemplate[]
  incidents         Incident[] // Team-assigned incidents
  teamLeadId        String?
  teamLead          User?              @relation("TeamLead", fields: [teamLeadId], references: [id])
}

model TeamMember {
  id     String   @id @default(cuid())
  userId String
  teamId String
  role   TeamRole @default(MEMBER)
  receiveTeamNotifications Boolean @default(true) // Team-specific notification preference

  user User @relation(fields: [userId], references: [id])
  team Team @relation(fields: [teamId], references: [id])

  @@unique([userId, teamId])
}

model Service {
  id                          String                @id @default(cuid())
    name                        String                @unique
  description                 String?
  region                      String? // Service hosting region (e.g., US-East, EU-West)
  slaTier                     String? // e.g., Gold, Silver, Bronze
  status                      ServiceStatus         @default(OPERATIONAL)
  targetAckMinutes            Int                   @default(15)
  targetResolveMinutes        Int                   @default(120)
  teamId                      String?
  escalationPolicyId          String?
  slackWebhookUrl             String? // Per-service Slack Webhook URL (only notification config at service level)
  slackChannel                String? // Slack channel name (e.g., #incidents)
  slackWorkspaceId            String? // Slack workspace ID for future multi-workspace support
  slackIntegrationId          String?               @unique // Reference to SlackIntegration (OAuth-based)
  webhookUrl                  String? // Per-service generic webhook URL
  serviceNotificationChannels NotificationChannel[] @default([]) // Service-level notification channels (isolated from escalation)
  serviceNotifyOnTriggered    Boolean               @default(true)
  serviceNotifyOnAck          Boolean               @default(true)
  serviceNotifyOnResolved     Boolean               @default(true)
  serviceNotifyOnSlaBreach    Boolean               @default(false)
  slaDefinitions              SLADefinition[]
  createdAt                   DateTime              @default(now())
  updatedAt                   DateTime              @updatedAt

  team      Team?             @relation(fields: [teamId], references: [id])
  incidents Incident[]
  policy    EscalationPolicy? @relation(fields: [escalationPolicyId], references: [id])

  integrations        Integration[]
  alerts              Alert[]
  incidentTemplates   IncidentTemplate[]
  statusPageServices  StatusPageService[]
  webhookIntegrations WebhookIntegration[]
  slackIntegration    SlackIntegration?    @relation("ServiceSlackIntegration", fields: [slackIntegrationId], references: [id], onDelete: Cascade)

}

// Enhanced Escalation Policy
model EscalationPolicy {
  id          String  @id @default(cuid())
    name        String  @unique
  description String?

  // Replaced simple JSON with relational steps
  steps EscalationRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services Service[]
}

model EscalationRule {
  id       String           @id @default(cuid())
  policyId String
  policy   EscalationPolicy @relation(fields: [policyId], references: [id])

  delayMinutes Int @default(0) // Time to wait before escalating to next step
  stepOrder    Int // 0, 1, 2...

  // Target type and ID - one of these will be set based on targetType
  targetType       EscalationTargetType @default(USER)
  targetUserId     String?
  targetTeamId     String?
  targetScheduleId String?

  // Notification channels for this escalation step (overrides user preferences if set)
  notificationChannels NotificationChannel[] // Per-step channel configuration

  // Team-specific options
  notifyOnlyTeamLead Boolean @default(false) // If true, only notify team lead instead of all team members

  targetUser     User?           @relation(fields: [targetUserId], references: [id])
  targetTeam     Team?           @relation(fields: [targetTeamId], references: [id])
  targetSchedule OnCallSchedule? @relation(fields: [targetScheduleId], references: [id])
}

model Integration {
  id              String   @id @default(cuid())
  name            String
  type            String   @default("EVENTS_API_V2") // EVENTS_API_V2, EMAIL, etc.
  key             String   @unique // The routing key used in API calls
  signatureSecret String?  // HMAC secret for webhook signature verification
  enabled         Boolean  @default(true) // Enable/disable integration
  serviceId       String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id])
}

model WebhookIntegration {
  id        String   @id @default(cuid())
  serviceId String
    name      String   @unique // "Google Chat", "Microsoft Teams", etc.
  type      String // "GOOGLE_CHAT", "TEAMS", "DISCORD", "GENERIC"
  url       String
  secret    String? // For HMAC signature
  channel   String? // Channel/room name
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@index([serviceId])
}

// Slack OAuth Configuration (Global - stored in database)
model SlackOAuthConfig {
  id           String   @id @default(cuid())
  clientId     String // Slack App Client ID
  clientSecret String // Encrypted Slack App Client Secret
  redirectUri  String? // Custom redirect URI (optional)
  enabled      Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  updatedBy    String // User ID who last updated the config
  updater      User     @relation("SlackOAuthConfigUpdater", fields: [updatedBy], references: [id])

  @@unique([id]) // Only one config record
}


// OIDC Single Sign-On Configuration (Global - stored in database)
model OidcConfig {
  id             String   @id @default("default")
  issuer         String
  clientId       String
  clientSecret   String
  enabled        Boolean  @default(true)
  autoProvision  Boolean  @default(true)
  allowedDomains String[] @default([])
  roleMapping    Json?    @default("[]") // Schema: [{ claim: string, value: string, role: Role }]
  customScopes   String?  // e.g. "groups profile email"
  providerType   String?  // e.g. 'google', 'okta', 'azure', 'auth0', 'custom'
  providerLabel  String?  // Custom display name, e.g. "Acme Corp SSO"
  profileMapping Json?    @default("{}") // { department: "dept", jobTitle: "title", avatarUrl: "picture" }
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  updatedBy      String
  updater        User     @relation(fields: [updatedBy], references: [id])

  @@unique([id])
}

// Slack OAuth Integration
model SlackIntegration {
  id            String   @id @default(cuid())
  workspaceId   String // Slack workspace/team ID
  workspaceName String? // Slack workspace name
  botToken      String // Encrypted bot token (xoxb-...)
  signingSecret String? // Encrypted signing secret
  installedBy   String // User ID who installed the integration
  scopes        String[] // OAuth scopes granted
  enabled       Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  service   Service? @relation("ServiceSlackIntegration")
  installer User     @relation(fields: [installedBy], references: [id])

  @@unique([workspaceId]) // One integration per workspace (can be global or service-specific)
  @@index([workspaceId])
}

model Alert {
  id         String   @id @default(cuid())
  dedupKey   String? // The deduplication key from the event source
  status     String   @default("TRIGGERED") // TRIGGERED, RESOLVED
  payload    Json // The full event payload
  serviceId  String
  incidentId String?
  createdAt  DateTime @default(now())

  service  Service   @relation(fields: [serviceId], references: [id])
  incident Incident? @relation(fields: [incidentId], references: [id])

  @@index([serviceId, status]) // For querying alerts by service and status
  @@index([incidentId]) // For querying alerts by incident
  @@index([dedupKey, status]) // For deduplication queries
  @@index([createdAt]) // For time-based queries

  // SLA Performance Optimization: Retention-based query indexes
  @@index([createdAt, incidentId], name: "idx_alert_retention") // For retention cleanup with incident lookup
  @@index([serviceId, createdAt], name: "idx_alert_by_service") // For service-scoped time-range queries
}

model Incident {
  id                     String          @id @default(cuid())
  title                  String
  description            String?
  status                 IncidentStatus  @default(OPEN)
  urgency                IncidentUrgency @default(HIGH)
  visibility             IncidentVisibility @default(PUBLIC)
  priority               String? // P1, P2.. P5
  dedupKey               String? // Key for deduplication
  serviceId              String
  assigneeId             String?
  teamId                 String? // Team assignment (mutually exclusive with assigneeId)
  currentEscalationStep  Int? // Current step index (0-based)
  nextEscalationAt       DateTime? // When to execute next escalation step
  escalationStatus       String? // ESCALATING, COMPLETED, PAUSED
  escalationProcessingAt DateTime? // When escalation processing was claimed
  acknowledgedAt         DateTime? // When incident was acknowledged (for SLA tracking)
  resolvedAt             DateTime? // When incident was resolved (for SLA tracking)
  snoozedUntil           DateTime? // When to auto-unsnooze (for time-based snoozing)
  snoozeReason           String? // Reason for snoozing
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt

  service                 Service                  @relation(fields: [serviceId], references: [id])
  assignee                User?                    @relation(fields: [assigneeId], references: [id])
  team                    Team?                    @relation(fields: [teamId], references: [id])
  events                  IncidentEvent[]
  notes                   IncidentNote[]
  postmortem              Postmortem?
  statusPageAnnouncements StatusPageAnnouncement[]
  customFieldValues       CustomFieldValue[]
  alerts                  Alert[] // Relation to raw alerts
  notifications           Notification[]
  watchers                IncidentWatcher[]
  tags                    IncidentTag[]

  @@index([dedupKey]) // Index for fast deduplication lookups
  @@index([serviceId, dedupKey, status]) // For service-scoped deduplication checks
  @@index([nextEscalationAt, escalationStatus]) // Index for escalation processing queries
  @@index([escalationProcessingAt]) // For escalation processing locks
  @@index([snoozedUntil]) // Index for auto-unsnooze processing
  @@index([status, createdAt]) // For filtering incidents by status and date
  @@index([serviceId, status]) // For querying incidents by service and status
  @@index([assigneeId, status]) // For querying incidents by assignee and status
  @@index([teamId, status]) // For querying incidents by team and status
  @@index([createdAt]) // For time-based queries and sorting
  @@index([urgency, status]) // For filtering by urgency and status
  @@index([status, urgency, createdAt]) // Composite for count queries with urgency and date filter
  @@index([status, assigneeId]) // For unassigned count queries (assigneeId: null)

  // Performance Optimization: Indexes for Analytics & Dashboard Counts
  @@index([status]) // For simple count queries (e.g. "Open Incidents")
  @@index([acknowledgedAt]) // For MTTA calculations
  @@index([resolvedAt]) // For MTTR calculations

  // SLA Performance Optimization: World-Class Query Indexes
  @@index([createdAt, status], name: "idx_incident_retention") // For retention-based status queries
  @@index([serviceId, createdAt, status], name: "idx_incident_sla_by_service") // For service-scoped SLA queries
  @@index([createdAt, acknowledgedAt], name: "idx_incident_mtta_calc") // For MTTA range calculations
  @@index([createdAt, resolvedAt, status], name: "idx_incident_mttr_calc") // For MTTR with status filter
  @@index([assigneeId, createdAt, status], name: "idx_incident_assignee_load") // For assignee workload queries
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String? // Optional color for tag
  createdAt DateTime @default(now())

  incidents IncidentTag[]
}

model IncidentTag {
  id         String   @id @default(cuid())
  incidentId String
  tagId      String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([incidentId, tagId])
  @@index([incidentId])
  @@index([tagId])
}

model IncidentTemplate {
  id               String          @id @default(cuid())
    name             String          @unique
  description      String?
  title            String // Default title for incidents created from this template
  descriptionText  String? // Default description text
  defaultUrgency   IncidentUrgency @default(HIGH)
  defaultPriority  String? // P1-P5
  defaultServiceId String? // Default service to use
  createdById      String // User who created the template
  isPublic         Boolean         @default(false) // Whether template is available to all users
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  createdBy      User     @relation(fields: [createdById], references: [id])
  defaultService Service? @relation(fields: [defaultServiceId], references: [id])
  Team           Team?    @relation(fields: [teamId], references: [id])
  teamId         String?

  @@index([createdById])
}

model IncidentWatcher {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  role       String   @default("FOLLOWER") // FOLLOWER, STAKEHOLDER, EXEC
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@unique([incidentId, userId])
}

model IncidentEvent {
  id         String   @id @default(cuid())
  incidentId String
  message    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId, createdAt]) // For querying events by incident chronologically
  @@index([incidentId, message, createdAt], name: "idx_event_ack_search") // For ack event searches with message filtering
}

model IncidentNote {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  content    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId, createdAt]) // For querying notes by incident chronologically
}

model Postmortem {
  id          String    @id @default(cuid())
  incidentId  String    @unique // One postmortem per incident
  title       String
  summary     String? // Executive summary
  timeline    Json? // Timeline of events (JSON array)
  impact      Json? // Impact assessment (JSON object)
  rootCause   String? // Root cause analysis
  resolution  String? // How it was resolved
  actionItems Json? // Action items (JSON array)
  lessons     String? // Lessons learned
  status      String    @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  isPublic    Boolean   @default(true) // Public visibility on status page
  publishedAt DateTime?
  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  incident  Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  createdBy User     @relation(fields: [createdById], references: [id])

  @@index([incidentId])
  @@index([status, createdAt])
  @@index([createdById])
}

model OnCallSchedule {
  id              String           @id @default(cuid())
    name            String           @unique
  timeZone        String           @default("UTC")
  layers          OnCallLayer[]
  overrides       OnCallOverride[]
  shifts          OnCallShift[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  escalationRules EscalationRule[]
}

model OnCallLayer {
  id                  String    @id @default(cuid())
  scheduleId          String
  name                String
  start               DateTime
  end                 DateTime?
  rotationLengthHours Int       @default(24)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  schedule OnCallSchedule    @relation(fields: [scheduleId], references: [id])
  users    OnCallLayerUser[]
}

model OnCallLayerUser {
  id       String @id @default(cuid())
  layerId  String
  userId   String
  position Int    @default(0)

  layer OnCallLayer @relation(fields: [layerId], references: [id])
  user  User        @relation(fields: [userId], references: [id])

  @@unique([layerId, userId])
}

model OnCallOverride {
  id             String   @id @default(cuid())
  scheduleId     String
  userId         String
  replacesUserId String?
  start          DateTime
  end            DateTime
  createdAt      DateTime @default(now())

  schedule     OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user         User           @relation("OverrideUser", fields: [userId], references: [id])
  replacesUser User?          @relation("OverrideReplacesUser", fields: [replacesUserId], references: [id])
}

model OnCallShift {
  id         String   @id @default(cuid())
  scheduleId String
  userId     String
  start      DateTime
  end        DateTime

  schedule OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user     User           @relation(fields: [userId], references: [id])

  @@index([start, end]) // For date range queries (active shifts)
  @@index([userId, start, end]) // For user-specific shift queries
}

// Notification model for contact attempts
model Notification {
  id          String              @id @default(cuid())
  incidentId  String
  userId      String
  channel     NotificationChannel
  status      NotificationStatus  @default(PENDING)
  message     String?
  sentAt      DateTime?
  deliveredAt DateTime?
  failedAt    DateTime?
  errorMsg    String?
  attempts    Int                 @default(0) // Retry attempt count
  createdAt   DateTime            @default(now())

  incident Incident @relation(fields: [incidentId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId]) // For querying notifications by incident
  @@index([userId]) // For querying notifications by user
  @@index([status, createdAt]) // For querying pending/failed notifications
  @@index([channel, status]) // For querying by channel and status
}

model InAppNotification {
  id         String                @id @default(cuid())
  userId     String
  type       InAppNotificationType
  title      String
  message    String
  entityType String?
  entityId   String?
  readAt     DateTime?
  createdAt  DateTime              @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt]) // For chronological queries
  @@index([userId, readAt]) // For unread count queries
  @@index([userId, readAt, createdAt]) // Optomized for "Unread" queries (readAt: null)
}

// User device tokens for push notifications
model UserDevice {
  id        String   @id @default(cuid())
  userId    String
  deviceId  String // Unique device identifier
  token     String // FCM/APNS token
  platform  String // 'ios', 'android', 'web'
  userAgent String? // Browser/device info
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@index([userId])
  @@index([token])
}

model AuditLog {
  id         String          @id @default(cuid())
  action     String
  entityType AuditEntityType
  entityId   String?
  actorId    String?
  details    Json?
  targetEmail String?         // For rate limiting queries (avoid JSON scan)
  ip          String?         // For rate limiting queries (avoid JSON scan)
  createdAt  DateTime        @default(now())

  actor User? @relation(fields: [actorId], references: [id])

  @@index([entityType, entityId]) // For querying audit logs by entity
  @@index([actorId, createdAt]) // For querying audit logs by actor
  @@index([createdAt]) // For time-based queries
  
  // Rate Limiting Performance Indexes
  @@index([action, targetEmail, createdAt]) // For checking email rate limits O(log n)
  @@index([action, ip, createdAt]) // For checking IP rate limits O(log n)
}

// User tokens for invite links, password resets, and admin reset links
// Tokens are stored as SHA256 hashes (never store raw tokens in DB)
model UserToken {
  id         String        @id @default(cuid())
  type       UserTokenType
  identifier String // typically the user's email (lowercased)
  tokenHash  String        @unique
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime      @default(now())
  metadata   Json?

  @@index([identifier, type])
  @@index([expiresAt])
}



model ApiKey {
  id         String    @id @default(cuid())
  name       String
  prefix     String
  tokenHash  String
  scopes     String[]
  userId     String
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  revokedAt  DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// System-level notification provider configuration
model NotificationProvider {
  id        String   @id @default(cuid())
  provider  String   @unique // 'twilio', 'resend', 'sendgrid', 'smtp', 'firebase', 'onesignal'
  enabled   Boolean  @default(false)
  // Encrypted configuration (JSON stored as text, should be encrypted in production)
  config    Json // Provider-specific configuration
  updatedBy String? // User ID who last updated
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@index([provider])
}

// Background Job Queue (PostgreSQL-based, no Redis needed)
enum JobType {
  ESCALATION
  NOTIFICATION
  AUTO_UNSNOOZE
  SCHEDULED_TASK
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model BackgroundJob {
  id          String    @id @default(cuid())
  type        JobType
  status      JobStatus @default(PENDING)
  scheduledAt DateTime // When to execute the job
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  error       String? // Error message if failed
  payload     Json // Job-specific data (incidentId, userId, etc.)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([type, status, scheduledAt]) // For efficient job polling
  @@index([status, scheduledAt]) // For finding pending jobs
  @@index([scheduledAt]) // For time-based queries
}

// Status Page Configuration
model StatusPage {
  id            String  @id @default(cuid())
    name          String  @default("Status Page") @unique
  organizationName String? // Dedicated organization name for email branding
  subdomain     String? @unique // Custom subdomain (e.g., status.yourcompany.com)
  customDomain  String? @unique // Custom domain (e.g., status.yourcompany.com)
  enabled       Boolean @default(false)
  showServices  Boolean @default(true)
  showIncidents Boolean @default(true)
  showMetrics   Boolean @default(true)
  showSubscribe Boolean @default(true)
  branding      Json? // Logo, colors, favicon
  footerText    String?
  contactEmail  String?
  contactUrl    String?

  // Privacy settings
  privacyMode              String? @default("PUBLIC") // PUBLIC, RESTRICTED, PRIVATE
  showIncidentDetails      Boolean @default(true)
  showIncidentTitles       Boolean @default(true)
  showIncidentDescriptions Boolean @default(true)
  showAffectedServices     Boolean @default(true)
  showIncidentTimestamps   Boolean @default(true)
  showServiceMetrics       Boolean @default(true)
  showServiceDescriptions  Boolean @default(true)
  showServiceRegions       Boolean @default(true)
  showServicesByRegion     Boolean @default(false)
  showServiceOwners        Boolean @default(false)
  showServiceSlaTier       Boolean @default(false)
  showTeamInformation      Boolean @default(false)
  showCustomFields         Boolean @default(false)
  showIncidentAssignees    Boolean @default(false)
  showIncidentUrgency      Boolean @default(true)
  showUptimeHistory        Boolean @default(true)
  showRecentIncidents      Boolean @default(true)
  showChangelog            Boolean @default(true)
  showRegionHeatmap        Boolean @default(true)
  showPostIncidentReview   Boolean @default(true)
  maxIncidentsToShow       Int     @default(50)
  incidentHistoryDays      Int     @default(90)
  allowedCustomFields      Json? // Array of custom field IDs to show
  dataRetentionDays        Int? // Auto-hide incidents older than X days
  requireAuth              Boolean @default(false) // Require authentication
  authProvider             String? // SSO provider if requireAuth=true
  emailProvider            String? // Email provider for subscription notifications (resend, sendgrid, smtp, or null for auto)
  enableUptimeExports      Boolean @default(false)

  // Status API access controls
  statusApiRequireToken       Boolean @default(false)
  statusApiRateLimitEnabled   Boolean @default(false)
  statusApiRateLimitMax       Int     @default(120)
  statusApiRateLimitWindowSec Int     @default(60)

  // Uptime threshold configuration
  uptimeExcellentThreshold Float @default(99.9) // Threshold for excellent uptime (green)
  uptimeGoodThreshold      Float @default(99.0) // Threshold for good uptime (yellow)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services      StatusPageService[]
  announcements StatusPageAnnouncement[]
  apiTokens     StatusPageApiToken[]
  subscriptions StatusPageSubscription[]
  webhooks      StatusPageWebhook[]

  @@index([enabled])
}

// Services shown on status page
model StatusPageService {
  id           String   @id @default(cuid())
  statusPageId String
  serviceId    String
  displayName  String? // Override service name for status page
  showOnPage   Boolean  @default(true)
  order        Int      @default(0)
  createdAt    DateTime @default(now())

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  service    Service    @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([statusPageId, serviceId])
  @@index([statusPageId, order])
}

// Announcements/Communications on status page
model StatusPageAnnouncement {
  id           String    @id @default(cuid())
  statusPageId String
  title        String
  message      String
  type         String    @default("INFO") // INFO, WARNING, MAINTENANCE, INCIDENT
  incidentId   String? // Link to incident if applicable
  affectedServiceIds Json? // Array of affected service IDs (for maintenance/impact mapping)
  startDate    DateTime
  endDate      DateTime?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  incident   Incident?  @relation(fields: [incidentId], references: [id], onDelete: SetNull)

  @@index([statusPageId, isActive, startDate])
  @@index([incidentId])
}

model StatusPageApiToken {
  id           String   @id @default(cuid())
  statusPageId String
  name         String
  prefix       String
  tokenHash    String
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime?
  revokedAt    DateTime?

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@unique([tokenHash])
  @@index([statusPageId, revokedAt])
}

// Status Page Subscriptions (Email notifications)
model StatusPageSubscription {
  id                String    @id @default(cuid())
  statusPageId      String
  email             String
  phone             String? // For SMS (future)
  token             String    @unique // Unsubscribe token
  subscribedAt      DateTime  @default(now())
  unsubscribedAt    DateTime?
  verified          Boolean   @default(false)
  verificationToken String?
  preferences       Json? // Notification preferences (all incidents, major only, etc.)

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@unique([statusPageId, email])
  @@index([statusPageId, verified])
  @@index([token])
}

// Status Page Webhooks (External integrations)
model StatusPageWebhook {
  id              String    @id @default(cuid())
  statusPageId    String
  url             String
  secret          String // Webhook secret for verification
  events          Json // Array of events to send (incident.created, incident.updated, etc.)
  enabled         Boolean   @default(true)
  lastTriggeredAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  @@index([statusPageId, enabled])
}

// Custom Fields System
model CustomField {
  id           String          @id @default(cuid())
  name         String
  key          String          @unique // Unique identifier (e.g., "customer_id")
  type         CustomFieldType
  required     Boolean         @default(false)
  defaultValue String?
  options      Json? // For SELECT type: array of options
  order        Int             @default(0)
  showInList   Boolean         @default(false) // Show in incident table
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  values CustomFieldValue[]

  @@index([key])
  @@index([order])
}

enum CustomFieldType {
  TEXT
  NUMBER
  DATE
  SELECT
  BOOLEAN
  URL
  EMAIL
}

model CustomFieldValue {
  id            String   @id @default(cuid())
  incidentId    String
  customFieldId String
  value         String? // Store as string, parse based on field type
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  incident    Incident    @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  customField CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)

  @@unique([incidentId, customFieldId])
  @@index([incidentId])
  @@index([customFieldId])
  @@index([value]) // For filtering
}

// Telemetry Metrics Rollup
model MetricRollup {
  id        String   @id @default(cuid())
  name      String   // e.g., 'http.request.duration', 'http.request.status'
  bucket    DateTime // Time bucket start
  serviceId String?  // Optional service association
  count     Int      // Number of sample points
  sum       Float    // Sum of values
  min       Float?
  max       Float?
  tags      Json?    // Additional dimensions (status code, method, etc.)

  createdAt DateTime @default(now())

  @@index([name, bucket])
  @@index([serviceId, bucket])
  @@index([bucket])
}

// System-wide settings (singleton pattern)
model SystemSettings {
  id        String   @id @default("default")
  appUrl    String?  // Application base URL for links in emails, webhooks, etc.
  encryptionKey String? // Hex-encoded 32-byte key for encrypting secrets
  
  // Data Retention Policy (days)
  incidentRetentionDays  Int @default(730)  // 2 years - how long to keep incident data
  alertRetentionDays     Int @default(365)  // 1 year - how long to keep alert data
  logRetentionDays       Int @default(90)   // 90 days - how long to keep log entries
  metricsRetentionDays   Int @default(365)  // 1 year - how long to keep metric rollups
  realTimeWindowDays     Int @default(90)   // 90 days - real-time queries, older uses rollups
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Pre-aggregated incident metrics for historical data performance
// Used for queries beyond realTimeWindowDays
model IncidentMetricRollup {
  id          String   @id @default(cuid())
  date        DateTime // Start of the period (day/week/month)
  granularity String   @default("daily") // 'daily', 'weekly', 'monthly'
  serviceId   String?  // Optional: per-service rollup
  teamId      String?  // Optional: per-team rollup
  
  // Incident Counts
  totalIncidents          Int @default(0)
  openIncidents           Int @default(0)
  acknowledgedIncidents   Int @default(0)
  resolvedIncidents       Int @default(0)
  highUrgencyIncidents    Int @default(0)
  mediumUrgencyIncidents  Int @default(0)
  lowUrgencyIncidents     Int @default(0)
  
  // Priority breakdown (P1-P5)
  p1Incidents   Int @default(0)
  p2Incidents   Int @default(0)
  p3Incidents   Int @default(0)
  p4Incidents   Int @default(0)
  p5Incidents   Int @default(0)
  
  // SLA Metrics (stored in milliseconds for precision)
  mttaSum   BigInt @default(0) // Sum of MTTA values
  mttaCount Int    @default(0) // Count for averaging
  mttrSum   BigInt @default(0) // Sum of MTTR values  
  mttrCount Int    @default(0) // Count for averaging
  
  // SLA Compliance
  ackSlaMet       Int @default(0)
  ackSlaBreached  Int @default(0)
  resolveSlaMet   Int @default(0)
  resolveSlaBreached Int @default(0)
  
  // Event Counts
  escalationCount  Int @default(0)
  reopenCount      Int @default(0)
  autoResolveCount Int @default(0)
  alertCount       Int @default(0)
  
  // After Hours
  afterHoursCount Int @default(0)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([date])
  @@index([granularity, date])
  @@index([serviceId, date])
  @@index([teamId, date])
  @@unique([date, granularity, serviceId, teamId])
}

// ⚙️ Governance / System Config
// Stores system-wide policies and security markers (encryption fingerprint, canary)
model SystemConfig {
  key       String   @id // e.g., 'encryption_fingerprint'
  value     Json     // Flexible JSON config
  updatedAt DateTime @updatedAt
  updatedBy String?
}

// Bronze Tier: Raw Log Storage
model LogEntry {
  id        String   @id @default(cuid())
  level     String   // 'info', 'error', 'warn', etc.
  message   String
  timestamp DateTime
  serviceId String?  
  context   Json?    // Structured log context

  createdAt DateTime @default(now())

  @@index([timestamp])
  @@index([serviceId, timestamp])
}

// SLA Management
model SLADefinition {
  id          String   @id @default(cuid())
  name        String
  description String?
  
  // Targets (minutes)
  targetAckTime     Int? 
  targetResolveTime Int? 
  
  // Scope of Applicability
  serviceId String?
  service   Service?  @relation(fields: [serviceId], references: [id]) 
  priority  String? // Filter by priority (e.g. "P1")
  
  // SLA Specifics
  target     Float    // e.g. 99.9
  window     String   // e.g. '30d'
  metricType String   // e.g. 'UPTIME', 'MTTA'
  version    Int      @default(1)

  activeFrom DateTime @default(now())
  activeTo   DateTime?
  
  snapshots SLASnapshot[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Daily SLA Compliance Snapshots
model SLASnapshot {
  id              String   @id @default(cuid())
  slaDefinitionId String
  date            DateTime // Midnight of the day captured
  
  totalIncidents Int
  metAckTime     Int      // Count of incidents meeting ack SLA
  metResolveTime Int      // Count of incidents meeting resolve SLA
  complianceScore Float   // 0-100%
  
  slaDefinition SLADefinition @relation(fields: [slaDefinitionId], references: [id])
  
  createdAt DateTime @default(now())

  @@unique([date, slaDefinitionId])
}

model SLAPerformanceLog {
  id              String   @id @default(cuid())
  timestamp       DateTime @default(now())
  
  serviceId       String?
  teamId          String?
  windowDays      Int
  
  durationMs      Int
  incidentCount   Int
  
  @@index([timestamp])
  @@index([durationMs])
  @@map("sla_performance_logs")
}

// Distributed cron scheduler state for production multi-worker environments
model CronSchedulerState {
  id              String    @id @default("singleton") // Only one row exists
  lastRunAt       DateTime?
  lastSuccessAt   DateTime?
  lastError       String?
  nextRunAt       DateTime?
  lastRollupDate  String?   // "YYYY-MM-DD" format
  lockedBy        String?   // Worker instance ID holding the lock
  lockedAt        DateTime? // When lock was acquired
  updatedAt       DateTime  @updatedAt
  
  @@map("cron_scheduler_state")
}
