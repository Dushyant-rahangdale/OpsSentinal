generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
  RESPONDER
}

enum UserStatus {
  INVITED
  ACTIVE
  DISABLED
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

enum AuditEntityType {
  USER
  TEAM
  TEAM_MEMBER
  SERVICE
}

enum ServiceStatus {
  OPERATIONAL
  DEGRADED
  PARTIAL_OUTAGE
  MAJOR_OUTAGE
  MAINTENANCE
}

enum IncidentStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
  SNOOZED
  SUPPRESSED
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  SLACK
  WEBHOOK
}

enum DigestLevel {
  HIGH
  ALL
  NONE
}

enum IncidentUrgency {
  LOW
  HIGH
}

enum EscalationTargetType {
  USER
  TEAM
  SCHEDULE
}

model User {
  id                        String      @id @default(cuid())
  name                      String
  email                     String      @unique
  role                      Role        @default(USER)
  status                    UserStatus  @default(INVITED)
  passwordHash              String?
  timeZone                  String      @default("UTC")
  dailySummary              Boolean     @default(true)
  incidentDigest            DigestLevel @default(HIGH)
  // Notification preferences (user-level, like PagerDuty)
  emailNotificationsEnabled Boolean     @default(false)
  smsNotificationsEnabled   Boolean     @default(false)
  pushNotificationsEnabled  Boolean     @default(false)
  phoneNumber               String? // For SMS notifications
  invitedAt                 DateTime?
  deactivatedAt             DateTime?
  createdAt                 DateTime    @default(now())
  updatedAt                 DateTime    @updatedAt

  assignedIncidents    Incident[]
  teamMemberships      TeamMember[]
  onCallShifts         OnCallShift[]
  escalationRules      EscalationRule[]
  incidentNotes        IncidentNote[]
  postmortems          Postmortem[]
  notifications        Notification[]
  incidentWatchers     IncidentWatcher[]
  auditLogs            AuditLog[]
  overrides            OnCallOverride[]       @relation("OverrideUser")
  overrideReplacements OnCallOverride[]       @relation("OverrideReplacesUser")
  layerAssignments     OnCallLayerUser[]
  accounts             Account[]
  sessions             Session[]
  apiKeys              ApiKey[]
  incidentTemplates    IncidentTemplate[]
  updatedProviders     NotificationProvider[]
}

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members           TeamMember[]
  services          Service[]
  escalationRules   EscalationRule[]
  incidentTemplates IncidentTemplate[]
}

model TeamMember {
  id     String   @id @default(cuid())
  userId String
  teamId String
  role   TeamRole @default(MEMBER)

  user User @relation(fields: [userId], references: [id])
  team Team @relation(fields: [teamId], references: [id])

  @@unique([userId, teamId])
}

model Service {
  id                   String        @id @default(cuid())
  name                 String
  description          String?
  status               ServiceStatus @default(OPERATIONAL)
  targetAckMinutes     Int           @default(15)
  targetResolveMinutes Int           @default(120)
  teamId               String?
  escalationPolicyId   String?
  slackWebhookUrl      String? // Per-service Slack Webhook URL (only notification config at service level)
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt

  team      Team?             @relation(fields: [teamId], references: [id])
  incidents Incident[]
  policy    EscalationPolicy? @relation(fields: [escalationPolicyId], references: [id])

  integrations      Integration[]
  alerts            Alert[]
  incidentTemplates IncidentTemplate[]
  statusPageServices StatusPageService[]
}

// Enhanced Escalation Policy
model EscalationPolicy {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Replaced simple JSON with relational steps
  steps EscalationRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  services Service[]
}

model EscalationRule {
  id       String           @id @default(cuid())
  policyId String
  policy   EscalationPolicy @relation(fields: [policyId], references: [id])

  delayMinutes Int @default(0) // Time to wait before escalating to next step
  stepOrder    Int // 0, 1, 2...

  // Target type and ID - one of these will be set based on targetType
  targetType       EscalationTargetType @default(USER)
  targetUserId     String?
  targetTeamId     String?
  targetScheduleId String?

  // Note: Notification channels are determined by user preferences, not policy steps
  // Users choose how they want to be notified (email, SMS, push) in their settings

  targetUser     User?           @relation(fields: [targetUserId], references: [id])
  targetTeam     Team?           @relation(fields: [targetTeamId], references: [id])
  targetSchedule OnCallSchedule? @relation(fields: [targetScheduleId], references: [id])
}

model Integration {
  id        String   @id @default(cuid())
  name      String
  type      String   @default("EVENTS_API_V2") // EVENTS_API_V2, EMAIL, etc.
  key       String   @unique // The routing key used in API calls
  serviceId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  service Service @relation(fields: [serviceId], references: [id])
}

model Alert {
  id         String   @id @default(cuid())
  dedupKey   String? // The deduplication key from the event source
  status     String   @default("TRIGGERED") // TRIGGERED, RESOLVED
  payload    Json // The full event payload
  serviceId  String
  incidentId String?
  createdAt  DateTime @default(now())

  service  Service   @relation(fields: [serviceId], references: [id])
  incident Incident? @relation(fields: [incidentId], references: [id])

  @@index([serviceId, status]) // For querying alerts by service and status
  @@index([incidentId]) // For querying alerts by incident
  @@index([dedupKey, status]) // For deduplication queries
  @@index([createdAt]) // For time-based queries
}

model Incident {
  id                    String          @id @default(cuid())
  title                 String
  description           String?
  status                IncidentStatus  @default(OPEN)
  urgency               IncidentUrgency @default(HIGH)
  priority              String? // P1, P2.. P5
  dedupKey              String? // Key for deduplication
  serviceId             String
  assigneeId            String?
  currentEscalationStep Int? // Current step index (0-based)
  nextEscalationAt      DateTime? // When to execute next escalation step
  escalationStatus      String? // ESCALATING, COMPLETED, PAUSED
  acknowledgedAt        DateTime? // When incident was acknowledged (for SLA tracking)
  resolvedAt            DateTime? // When incident was resolved (for SLA tracking)
  snoozedUntil          DateTime? // When to auto-unsnooze (for time-based snoozing)
  snoozeReason          String? // Reason for snoozing
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  service       Service           @relation(fields: [serviceId], references: [id])
  assignee      User?             @relation(fields: [assigneeId], references: [id])
  events        IncidentEvent[]
  notes         IncidentNote[]
  postmortem    Postmortem?
  statusPageAnnouncements StatusPageAnnouncement[]
  customFieldValues CustomFieldValue[]
  alerts        Alert[] // Relation to raw alerts
  notifications Notification[]
  watchers      IncidentWatcher[]
  tags          IncidentTag[]

  @@index([dedupKey]) // Index for fast deduplication lookups
  @@index([nextEscalationAt, escalationStatus]) // Index for escalation processing queries
  @@index([snoozedUntil]) // Index for auto-unsnooze processing
  @@index([status, createdAt]) // For filtering incidents by status and date
  @@index([serviceId, status]) // For querying incidents by service and status
  @@index([assigneeId, status]) // For querying incidents by assignee and status
  @@index([createdAt]) // For time-based queries and sorting
  @@index([urgency, status]) // For filtering by urgency and status
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String? // Optional color for tag
  createdAt DateTime @default(now())

  incidents IncidentTag[]
}

model IncidentTag {
  id         String   @id @default(cuid())
  incidentId String
  tagId      String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([incidentId, tagId])
  @@index([incidentId])
  @@index([tagId])
}

model IncidentTemplate {
  id               String          @id @default(cuid())
  name             String
  description      String?
  title            String // Default title for incidents created from this template
  descriptionText  String? // Default description text
  defaultUrgency   IncidentUrgency @default(HIGH)
  defaultPriority  String? // P1-P5
  defaultServiceId String? // Default service to use
  createdById      String // User who created the template
  isPublic         Boolean         @default(false) // Whether template is available to all users
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  createdBy      User     @relation(fields: [createdById], references: [id])
  defaultService Service? @relation(fields: [defaultServiceId], references: [id])
  Team           Team?    @relation(fields: [teamId], references: [id])
  teamId         String?

  @@index([createdById])
}

model IncidentWatcher {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  role       String   @default("FOLLOWER") // FOLLOWER, STAKEHOLDER, EXEC
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@unique([incidentId, userId])
}

model IncidentEvent {
  id         String   @id @default(cuid())
  incidentId String
  message    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)

  @@index([incidentId, createdAt]) // For querying events by incident chronologically
}

model IncidentNote {
  id         String   @id @default(cuid())
  incidentId String
  userId     String
  content    String
  createdAt  DateTime @default(now())

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId, createdAt]) // For querying notes by incident chronologically
}

model Postmortem {
  id          String   @id @default(cuid())
  incidentId String   @unique // One postmortem per incident
  title       String
  summary     String? // Executive summary
  timeline    Json? // Timeline of events (JSON array)
  impact      Json? // Impact assessment (JSON object)
  rootCause   String? // Root cause analysis
  resolution  String? // How it was resolved
  actionItems Json? // Action items (JSON array)
  lessons     String? // Lessons learned
  status      String   @default("DRAFT") // DRAFT, PUBLISHED, ARCHIVED
  publishedAt DateTime?
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  incident Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  createdBy User    @relation(fields: [createdById], references: [id])

  @@index([incidentId])
  @@index([status, createdAt])
  @@index([createdById])
}

model OnCallSchedule {
  id              String           @id @default(cuid())
  name            String
  timeZone        String           @default("UTC")
  layers          OnCallLayer[]
  overrides       OnCallOverride[]
  shifts          OnCallShift[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  escalationRules EscalationRule[]
}

model OnCallLayer {
  id                  String    @id @default(cuid())
  scheduleId          String
  name                String
  start               DateTime
  end                 DateTime?
  rotationLengthHours Int       @default(24)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  schedule OnCallSchedule    @relation(fields: [scheduleId], references: [id])
  users    OnCallLayerUser[]
}

model OnCallLayerUser {
  id       String @id @default(cuid())
  layerId  String
  userId   String
  position Int    @default(0)

  layer OnCallLayer @relation(fields: [layerId], references: [id])
  user  User        @relation(fields: [userId], references: [id])

  @@unique([layerId, userId])
}

model OnCallOverride {
  id             String   @id @default(cuid())
  scheduleId     String
  userId         String
  replacesUserId String?
  start          DateTime
  end            DateTime
  createdAt      DateTime @default(now())

  schedule     OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user         User           @relation("OverrideUser", fields: [userId], references: [id])
  replacesUser User?          @relation("OverrideReplacesUser", fields: [replacesUserId], references: [id])
}

model OnCallShift {
  id         String   @id @default(cuid())
  scheduleId String
  userId     String
  start      DateTime
  end        DateTime

  schedule OnCallSchedule @relation(fields: [scheduleId], references: [id])
  user     User           @relation(fields: [userId], references: [id])
}

// Notification model for contact attempts
model Notification {
  id          String              @id @default(cuid())
  incidentId  String
  userId      String
  channel     NotificationChannel
  status      NotificationStatus  @default(PENDING)
  message     String?
  sentAt      DateTime?
  deliveredAt DateTime?
  failedAt    DateTime?
  errorMsg    String?
  createdAt   DateTime            @default(now())

  incident Incident @relation(fields: [incidentId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@index([incidentId]) // For querying notifications by incident
  @@index([userId]) // For querying notifications by user
  @@index([status, createdAt]) // For querying pending/failed notifications
  @@index([channel, status]) // For querying by channel and status
}

model AuditLog {
  id         String          @id @default(cuid())
  action     String
  entityType AuditEntityType
  entityId   String?
  actorId    String?
  details    Json?
  createdAt  DateTime        @default(now())

  actor User? @relation(fields: [actorId], references: [id])

  @@index([entityType, entityId]) // For querying audit logs by entity
  @@index([actorId, createdAt]) // For querying audit logs by actor
  @@index([createdAt]) // For time-based queries
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model ApiKey {
  id         String    @id @default(cuid())
  name       String
  prefix     String
  tokenHash  String
  scopes     String[]
  userId     String
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  revokedAt  DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// System-level notification provider configuration
model NotificationProvider {
  id        String   @id @default(cuid())
  provider  String   @unique // 'twilio', 'resend', 'sendgrid', 'smtp', 'firebase', 'onesignal'
  enabled   Boolean  @default(false)
  // Encrypted configuration (JSON stored as text, should be encrypted in production)
  config    Json // Provider-specific configuration
  updatedBy String? // User ID who last updated
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  updatedByUser User? @relation(fields: [updatedBy], references: [id])

  @@index([provider])
}

// Background Job Queue (PostgreSQL-based, no Redis needed)
enum JobType {
  ESCALATION
  NOTIFICATION
  AUTO_UNSNOOZE
  SCHEDULED_TASK
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model BackgroundJob {
  id          String    @id @default(cuid())
  type        JobType
  status      JobStatus @default(PENDING)
  scheduledAt DateTime // When to execute the job
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  error       String? // Error message if failed
  payload     Json // Job-specific data (incidentId, userId, etc.)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([type, status, scheduledAt]) // For efficient job polling
  @@index([status, scheduledAt]) // For finding pending jobs
  @@index([scheduledAt]) // For time-based queries
}

// Status Page Configuration
model StatusPage {
  id              String   @id @default(cuid())
  name            String   @default("Status Page")
  subdomain       String?  @unique // Custom subdomain (e.g., status.yourcompany.com)
  customDomain    String?  @unique // Custom domain (e.g., status.yourcompany.com)
  enabled         Boolean  @default(true)
  showServices    Boolean  @default(true)
  showIncidents   Boolean  @default(true)
  showMetrics     Boolean  @default(true)
  branding        Json?    // Logo, colors, favicon
  footerText      String?
  contactEmail    String?
  contactUrl      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  services        StatusPageService[]
  announcements   StatusPageAnnouncement[]

  @@index([enabled])
}

// Services shown on status page
model StatusPageService {
  id          String   @id @default(cuid())
  statusPageId String
  serviceId  String
  displayName String? // Override service name for status page
  showOnPage Boolean  @default(true)
  order      Int      @default(0)
  createdAt  DateTime @default(now())

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  service    Service    @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([statusPageId, serviceId])
  @@index([statusPageId, order])
}

// Announcements/Communications on status page
model StatusPageAnnouncement {
  id          String   @id @default(cuid())
  statusPageId String
  title       String
  message     String
  type        String   @default("INFO") // INFO, WARNING, MAINTENANCE, INCIDENT
  incidentId  String?  // Link to incident if applicable
  startDate   DateTime
  endDate     DateTime?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  statusPage StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)
  incident   Incident?  @relation(fields: [incidentId], references: [id], onDelete: SetNull)

  @@index([statusPageId, isActive, startDate])
  @@index([incidentId])
}

// Custom Fields System
model CustomField {
  id          String   @id @default(cuid())
  name        String
  key         String   @unique // Unique identifier (e.g., "customer_id")
  type        CustomFieldType
  required    Boolean  @default(false)
  defaultValue String?
  options     Json?    // For SELECT type: array of options
  order       Int      @default(0)
  showInList  Boolean  @default(false) // Show in incident table
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  values      CustomFieldValue[]

  @@index([key])
  @@index([order])
}

enum CustomFieldType {
  TEXT
  NUMBER
  DATE
  SELECT
  BOOLEAN
  URL
  EMAIL
}

model CustomFieldValue {
  id            String   @id @default(cuid())
  incidentId    String
  customFieldId String
  value         String?  // Store as string, parse based on field type
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  incident    Incident    @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  customField CustomField @relation(fields: [customFieldId], references: [id], onDelete: Cascade)

  @@unique([incidentId, customFieldId])
  @@index([incidentId])
  @@index([customFieldId])
  @@index([value]) // For filtering
}
